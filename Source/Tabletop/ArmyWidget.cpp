
#include "ArmyWidget.h"

#include "ArmyData.h"
#include "Components/Button.h"
#include "Components/ComboBoxString.h"
#include "Components/TextBlock.h"
#include "Controllers/SetupPlayerController.h"
#include "GameFramework/PlayerState.h"
#include "Gamemodes/SetupGamemode.h"

namespace FactionNameConverter
{
    FString FactionDisplay(EFaction F)
    {
        if (UEnum* Enum = StaticEnum<EFaction>())
        {
            return Enum->GetDisplayNameTextByValue((int64)F).ToString();
        }
        return TEXT("Unknown");
    }
}

static bool FactionFromString(const FString& S, EFaction& Out)
{
    const UEnum* Enum = StaticEnum<EFaction>();
    if (!Enum) return false;

    for (int32 i = 0; i < Enum->NumEnums(); ++i)
    {
#if WITH_EDITOR
        // Skip entries marked Hidden/HiddenByDefault in editor builds
        if (Enum->HasMetaData(TEXT("Hidden"), i) || Enum->HasMetaData(TEXT("HiddenByDefault"), i))
        {
            continue;
        }
#endif
        // Skip autogenerated _MAX sentinel if present
        if (Enum->GetNameByIndex(i).ToString().EndsWith(TEXT("_MAX")))
        {
            continue;
        }

        const int64 Value = Enum->GetValueByIndex(i);
        const FString Disp = Enum->GetDisplayNameTextByValue(Value).ToString();

        if (Disp.Equals(S, ESearchCase::CaseSensitive))
        {
            Out = static_cast<EFaction>(Value);
            return true;
        }
    }
    return false;
}

ASetupGameState* UArmyWidget::GS() const
{
    return GetWorld() ? GetWorld()->GetGameState<ASetupGameState>() : nullptr;
}

ASetupPlayerController* UArmyWidget::PC() const
{
    return GetOwningPlayer<ASetupPlayerController>();
}

void UArmyWidget::OnReadyUpChanged()
{
    RefreshFromState();
}

void UArmyWidget::NativeConstruct()
{
    Super::NativeConstruct();

    if (ASetupGameState* S = GS())
    {
        S->OnPlayerReadyUp.AddDynamic(this, &UArmyWidget::OnReadyUpChanged);
        S->OnArmySelectionChanged.AddDynamic(this, &UArmyWidget::RefreshFromState);
        S->OnPhaseChanged.AddDynamic(this, &UArmyWidget::RefreshFromState);
    }

    if (ASetupGameState* S = GS())
    {
        S->bP1Ready = false;
        S->bP2Ready = false;
    }
        

    if (FactionDropdown)
    {
        FactionDropdown->OnSelectionChanged.AddDynamic(this, &UArmyWidget::OnFactionChanged);
        BuildFactionDropdown();
    }
    if (P1ReadyBtn) P1ReadyBtn->OnClicked.AddDynamic(this, &UArmyWidget::OnP1ReadyClicked);
    if (P2ReadyBtn) P2ReadyBtn->OnClicked.AddDynamic(this, &UArmyWidget::OnP2ReadyClicked);
    if (BothReady)  BothReady ->OnClicked.AddDynamic(this, &UArmyWidget::OnBothReadyClicked);

    RefreshFromState();
}

void UArmyWidget::NativeDestruct()
{
    if (ASetupGameState* S = GS())
    {
        S->OnArmySelectionChanged.RemoveDynamic(this, &UArmyWidget::RefreshFromState);
        S->OnPhaseChanged.RemoveDynamic(this, &UArmyWidget::RefreshFromState);
    }
    Super::NativeDestruct();
}

void UArmyWidget::BuildFactionDropdown()
{
    if (!FactionDropdown) return;
    FactionDropdown->ClearOptions();

    TSet<EFaction> Seen;

    if (ASetupGameState* S = GS(); S && S->FactionsTable)
    {
        // iterate the factions table rows
        for (const auto& Pair : S->FactionsTable->GetRowMap())
        {
            if (const FFactionRow* Row = reinterpret_cast<const FFactionRow*>(Pair.Value))
            {
                if (Row->Faction != EFaction::None)
                {
                    Seen.Add(Row->Faction);
                }
            }
        }
    }

    // Fallback: use the entire enum
    if (Seen.Num() == 0)
    {
        if (const UEnum* Enum = StaticEnum<EFaction>())
        {
            const int32 Num = Enum->NumEnums();
            for (int32 i = 0; i < Num; ++i)
            {
#if WITH_EDITOR
                // These keys exist only in editor builds
                if (Enum->HasMetaData(TEXT("Hidden"), i) ||
                    Enum->HasMetaData(TEXT("HiddenByDefault"), i))
                {
                    continue;
                }
#endif
                const int64 Value = Enum->GetValueByIndex(i);

                // Runtime-safe guards
                if (!Enum->IsValidEnumValue(Value))          continue; // skip invalid
                if (Enum->GetNameByIndex(i).ToString().EndsWith(TEXT("_MAX")))
                    continue; // skip sentinels if you use them

                const EFaction F = static_cast<EFaction>(Value);
                if (F != EFaction::None)
                {
                    Seen.Add(F);
                }
            }
        }
    }


    // Sort by display name
    TArray<EFaction> List = Seen.Array();
    List.Sort([](EFaction A, EFaction B) {
        return FactionNameConverter::FactionDisplay(A) < FactionNameConverter::FactionDisplay(B);
    });

    for (EFaction F : List)
    {
        FactionDropdown->AddOption(FactionNameConverter::FactionDisplay(F));
    }
}

void UArmyWidget::RefreshFromState()
{
    ASetupGameState* S = GS();
    ASetupPlayerController* LPC = PC();
    if (!S || !LPC) return;

    const FString N1 = (S->Player1 ? S->Player1->GetPlayerName() : TEXT("---"));
    const FString N2 = (S->Player2 ? S->Player2->GetPlayerName() : TEXT("---"));
    if (P1Name) P1Name->SetText(FText::FromString(N1));
    if (P2Name) P2Name->SetText(FText::FromString(N2));

    if (P1PickText) P1PickText->SetText(FText::FromString(FactionNameConverter::FactionDisplay(S->P1Faction)));
    if (P2PickText) P2PickText->SetText(FText::FromString(FactionNameConverter::FactionDisplay(S->P2Faction)));

    // Enable only your own Ready button
    const bool bLocalIsP1 = (LPC->PlayerState && LPC->PlayerState == S->Player1);
    const bool bLocalIsP2 = (LPC->PlayerState && LPC->PlayerState == S->Player2);
    if (P1ReadyBtn)
        P1ReadyBtn->SetIsEnabled(bLocalIsP1);
    if (P2ReadyBtn)
        P2ReadyBtn->SetIsEnabled(bLocalIsP2);

    // Host can advance when both ready & both picked
    if (BothReady)
    {
        const bool bHostSeat = bLocalIsP1; // host = player1
        const bool bAllReady = S->bP1Ready && S->bP2Ready;

        // Host can advance if both players ready and we're not already at final phase
        BothReady->SetIsEnabled(bHostSeat && bAllReady && S->Phase == ESetupPhase::ArmySelection);
    }
}

void UArmyWidget::OnFactionChanged(FString Selected, ESelectInfo::Type)
{
    EFaction Pick = EFaction::None;
    if (FactionFromString(Selected, Pick))
    {
        if (ASetupPlayerController* LPC = PC())
        {
            LPC->Server_SelectFaction(Pick);
        }
    }
}

void UArmyWidget::OnP1ReadyClicked()
{
    if (ASetupGameState* S = GS())
    if (ASetupPlayerController* LPC = PC())
    if (LPC->PlayerState == S->Player1)
        LPC->Server_SetReady(!S->bP1Ready);
}

void UArmyWidget::OnP2ReadyClicked()
{
    if (ASetupGameState* S = GS())
    if (ASetupPlayerController* LPC = PC())
    if (LPC->PlayerState == S->Player2)
        LPC->Server_SetReady(!S->bP2Ready);
}

void UArmyWidget::OnBothReadyClicked()
{
    if (ASetupGameState* S = GS())
    if (ASetupPlayerController* LPC = PC())
    if (LPC->PlayerState == S->Player1 && S->bP1Ready && S->bP2Ready &&
        S->P1Faction != EFaction::None && S->P2Faction != EFaction::None)
    {
        LPC->Server_SnapshotSetupToPS();
        LPC->Server_AdvanceFromArmy();
    }
}